#!/usr/bin/env python
# Copyright 2015 Blue Box Cloud, an IBM Company
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.


import argparse
import pytz
import re

from datetime import datetime, timedelta


def parse_log(logfile, play, min_duration):
    task_re = re.compile("TASK: \[(?P<task>[\w\W|\- ]+)\]")
    play_re = re.compile("PLAY \[(?P<play>[\w ]+)\]")
    date_re = re.compile(
        "(?P<date>(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday) "
        "\d+ (January|February|March|April|May|June|July|August|September"
        "|October|November|December) \d{4}\s+\d{2}:\d{2}:\d{2} \+0000) "
        "\((?P<duration>\d+:\d+:\d+\.\d+)\)\s+(?P<total_time>\d+:\d+:\d+\."
        "\d+)")
    task_counts = {}
    base_date = datetime(1901, 1, 1, 0, 0, 0, 0, pytz.UTC)
    last_task = None
    last_total_time = timedelta(0)
    with open(logfile) as log:
        current_play = None
        current_group = 0
        print "task;start;end;label;min_duration;color"
        for line in log:
            match = play_re.search(line)
            if match:
                current_play = match.group("play")
                current_group += 1
                continue
            if play and current_play != play:
                continue
            match = task_re.search(line)
            if match:
                task = match.group("task")
                match = date_re.search(next(log))
                if match:
                    duration = datetime.strptime(
                        match.group("duration"), "%H:%M:%S.%f")
                    duration = timedelta(
                        hours=duration.hour,
                        minutes=duration.minute,
                        seconds=duration.second,
                        microseconds=duration.microsecond
                    )
                    total_time = last_total_time + duration
                    if duration.total_seconds() < min_duration.total_seconds():
                        continue
                    full_task = "{0} | {1}".format(current_play, last_task)
                    if full_task in task_counts:
                        task_counts[full_task] += 1
                    else:
                        task_counts[full_task] = 1
                    print "{0};{1};{2};{3};{4};{5}".format(
                        "{0} #{1}".format(full_task, task_counts[full_task]),
                        base_date + last_total_time,
                        base_date + total_time,
                        "{0}={1}".format(full_task, duration.total_seconds()),
                        min_duration.total_seconds(),
                        current_group
                    )
                    last_task = task
                    last_total_time = total_time


def main():
    args = argparse.ArgumentParser()
    args.add_argument(
        "--min-duration", default="00:00:10.000",
        help="Filter out any task that takes less time"
    )
    args.add_argument(
        "--play",
        help="Only show tasks associated with this play"
    )
    args.add_argument('logfile')

    args = args.parse_args()

    min_duration = None
    if args.min_duration:
        min_duration = datetime.strptime(args.min_duration, "%H:%M:%S.%f")
        min_duration = timedelta(
            hours=min_duration.hour,
            minutes=min_duration.minute,
            seconds=min_duration.second,
            microseconds=min_duration.microsecond
        )

    parse_log(args.logfile, args.play, min_duration)


if __name__ == "__main__":
    main()
