# Copyright 2015 Blue Box Cloud, an IBM Company
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import pytz
import re

from datetime import datetime, timedelta


TASK_RE = re.compile("TASK: \[(?P<task>[\w\W|\- ]+)\]")
PLAY_RE = re.compile("PLAY \[(?P<play>[\w ]+)\]")
DATE_RE = re.compile(
    "(?P<date>(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday) "
    "\d+ (January|February|March|April|May|June|July|August|September"
    "|October|November|December) \d{4}\s+\d{2}:\d{2}:\d{2} \+0000) "
    "\((?P<duration>\d+:\d+:\d+\.\d+)\)\s+(?P<total_time>\d+:\d+:\d+\."
    "\d+)")


class UrsulaLogParser(object):
    name = "ursula-log-parser"
    help = "Parse log files generated by ursula"

    @classmethod
    def parse(cls, logfile, duration):
        min_duration = datetime.strptime(duration, "%H:%M:%S.%f")
        min_duration = timedelta(
            hours=min_duration.hour,
            minutes=min_duration.minute,
            seconds=min_duration.second,
            microseconds=min_duration.microsecond
        )
        task_counts = {}
        base_date = datetime(1901, 1, 1, 0, 0, 0, 0, pytz.UTC)
        last_task = None
        last_total_time = timedelta(0)
        with open(logfile) as log:
            current_play = None
            current_group = 0
            print "event;start;end;label;color"
            for line in log:
                match = PLAY_RE.search(line)
                if match:
                    current_play = match.group("play")
                    current_group += 1
                    continue
                match = TASK_RE.search(line)
                if not match:
                    continue
                task = match.group("task")
                match = DATE_RE.search(next(log))
                if not match:
                    continue
                duration = datetime.strptime(
                    match.group("duration"), "%H:%M:%S.%f")
                duration = timedelta(
                    hours=duration.hour,
                    minutes=duration.minute,
                    seconds=duration.second,
                    microseconds=duration.microsecond
                )
                total_time = last_total_time + duration
                if duration.total_seconds() < min_duration.total_seconds():
                    continue
                full_task = "{0} | {1}".format(current_play, last_task)
                if full_task in task_counts:
                    task_counts[full_task] += 1
                else:
                    task_counts[full_task] = 1
                print "{0};{1};{2};{3};{4}".format(
                    "{0} #{1}".format(full_task, task_counts[full_task]),
                    base_date + last_total_time,
                    base_date + total_time,
                    "{0}={1}".format(full_task, duration.total_seconds()),
                    current_group
                )
                last_task = task
                last_total_time = total_time
